#include "defines.h"
#include "io.h"

/**
  Функция проверяет знак. Если +, то в переменную знака записывается 1, если -, то в эту переменную записывается -1.
  Общее количество знаков увеличивается, указатель на текущий элемент передвигается на один вправо.
 * @brief check_sign
 * @param p_elem [in] - указатель на текущий анализируемый элемент
 * @param sign [in] - переменная, в которой хранится знак
 * @return Возвращает SIGN_ERROR, если знак уже был определен и был введен знак в неправильном месте, либо OK, если значение знака успешно зафиксировано.
 */
int check_sign(char **p_elem, int *sign)
{
    if (**p_elem == '+')
    {
        if (*sign == 0)
        {
            *sign = 1;
            *p_elem += 1;
        }
        else
            return SIGN_ERROR;
    }
    else if (**p_elem == '-')
    {
        if (*sign == 0)
        {
            *sign = -1;
            *p_elem += 1;
        }
        else
            return SIGN_ERROR;
    }
    return OK;
}

/**
  Функция ввода. Проверяет правильность ввода числа. В случае возникновения ошибок возвращает код ошибки.
 * @brief input
 * @param my_str [in] - строка ввода
 * @param M [in] - массив цифр мантиссы
 * @param n [in] - количество элементов цифр мантиссы
 * @param P [in] - число порядка
 * @param sign_m [in] - знак мантиссы
 * @param sign_p [in] - знак порядка
 * @param i_point [in] - место точки
 * @return Возвращает TOO_MUCH_SYMB, если в введенной строке больше заданных чисел, либо POINT_ERROR, если введенно больше одной точки в мантиссе,
 * либо INPUT_ERROR, если введенный символ не число, не точка и не 'e'/'E', либо M_COUNT_ERROR, если превышено допустимое количество цифр мантиссы,
 * либо P_COUNT_ERROR, если превышено допустимое количество цифр порядка, либо OK, если число успешно прочитано.
 */
int input(char *my_str, int M[], int *n, int *P, int *sign_m, int *sign_p, int *i_point)
{
    int count_point = 0; // число точек
    int E = 0; // встретилось E или нет
    int n_P; // количество цифр порядка
    int tmp; // переменная для преобразования цифр порядка в одно число
    int rc = OK; // переменная кода ошибки

    // получение строки
    printf("input number:\n");
    for (int k = 1; k < 31; k++)
    {
        if (k % 10 == 0)
            printf("|");
        else
            printf(" ");
    }
    printf("\n");
    fgets(my_str, 40, stdin);

    // вычисление длины строки и проверка на длину введенной строки
    int n_str = strlen(my_str);
    if (my_str[n_str - 1] != '\n')
    {
        printf("not an end\n");
        return TOO_MUCH_SYMB;
    }
    char *pe = my_str + n_str; // указатель на конец строки
    int i = 0; // подсчитывает количество элементов массива цифр мантиссы
    char *after_e, *begin = my_str; // указатель на символ после E, указатель на начало строки

    // проверка знака мантиссы
    rc = check_sign(&begin, sign_m);
    if (rc != OK)
        return rc;

    // считывание символов до E, если таковая есть, или до конца строки
    for (char *pcur = begin; pcur < pe - 1; pcur++)
    {
        // если текущий элемент строки число - оно записывается в массив цифр мантиссы
        if (isdigit(*pcur) != 0 && *pcur != 'E' && *pcur != 'e' && *pcur != '.')
        {
            M[i] = *(pcur) - '0'; // преобразование char к int
            i++; // инкрементирование индекса массива цифр мантиссы
        }
        // если текущий элемент строки равен "E"/"e", то сохраняется значение указателя на элемент, после E, цикл прекращается
        else if ((*pcur) == 'E' || (*pcur) == 'e')
        {
            after_e = pcur + 1;
            E = 1;
            break;
        }
        // если текущий элемент - точка, сохраняется индекс элемента, перед которым должна стоять точка
        else if (*pcur == '.')
        {
            if (count_point == 0) // проверка, что точки еще не было
            {
                // если точка стоит в самом начале строки, то место первого элемента в массиве цифр занимает ноль
                if (pcur == begin)
                {
                    M[i] = 0;
                    i++;
                }
                *i_point = i; // сохранение индекса
                count_point++; // инкрементирование количества точек
            }
            else
                return POINT_ERROR; // если найдено больше одной точки в мантиссе
        }
        else
            return INPUT_ERROR; // если в строке присутствуют какие-то другие символы - ввод некорректен
    }

    // проверка количества знаков мантиссы
    if (i > 30)
        return M_COUNT_ERROR;

    // если встретилось E, считывание символов после E
    if (E == 1)
    {
        // проверка знака порядка
        rc = check_sign(&after_e, sign_p);
        if (rc != OK)
            return rc;

        // вычисление количества цифр порядка
        n_P = pe - 1 - after_e;
        if ((n_P) > 5 || n_P < 1)
            return P_COUNT_ERROR; // если знаков порядка меньше одного или больше пяти

        // считывание цифр порядка и преобразование их в одно число
        for (char *pcur = after_e;  pcur < pe - 1; pcur++)
        {
            if (isdigit(*pcur) != 0 )
            {
                tmp = *(pcur) - '0';
                *P += tmp * pow(10, (n_P - 1));
                n_P--;
            }
            else
                return INPUT_ERROR; // если введены не числа - некорректный ввод
        }
    }
    // если знаки не ввели, то значения считаются положительными
    if (*sign_m == 0)
        *sign_m = 1;
    if (*sign_p == 0)
        *sign_p = 1;
    if (i == 0)
        return INPUT_ERROR;
    *n = i; // записываем окончательную длину массива цифр мантиссы

    return OK; // успешное завершение
}

/**
 * @brief output Функция вывода результата в нормализованнной форме
 * @param res [in] - массив цифр мантиссы результата
 * @param n [in] - количество элементов массива
 * @param P [in] - число порядка
 * @param sign_m [in] - знак мантиссы
 * @param sign_p [in] - знак порядка
 * @param i_point [in] - место точки
 */
void output(const int res[], int n, int P, int sign_m, int sign_p, int i_point)
{
    assert(n > 0);
    printf("Result is given in normalized form:\n");
    printf("%c0", (sign_m == 1) ? '+' : '-');
    for (int i = 0; i < n; i++)
    {
        if (i == i_point)
            printf(".");
        printf ("%d", res[i]);
    }
    printf ("E%c%d\n", (sign_p == 1) ? '+' : '-' , P);
}
