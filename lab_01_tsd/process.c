#include "defines.h"
#include "process.h"

/**
 * @brief mult Функция перемножает два числа, каждое из которых записано в массиве (элементы массивов - цифры чисел).
 * @param m1 [in] - массив цифр первого числа
 * @param m2 [in] - массив цифр второго числа
 * @param n1 [in] - количество элементов первого массива
 * @param n2 [in] - количество элементов второго массива
 * @param res [in] - полученное в результате умножения число, записанное в массиве
 * @param len [in] - длина массива-результата
 */
void mult(const int m1[], const int m2[], int n1, int n2, int res[], int len)
{
    // обнуление массива-результата
    for (int i = 0; i < len; i++)
        res[i] = 0;
    // поразрядное умножение
    for (int i = 0; i < n1; i++)
        for (int j = 0; j < n2; j++)
            res[i + j] += m1[i] * m2[j];

    // перенос остатка
    for (int i = 0; i < len - 1; i++)
    {
        res[i + 1] += res[i] / 10;
        res[i] %= 10;
    }
}

/**
 * @brief reverse_arr Функция "переворачивает" массив. Последний элемент массива становится на место первого, первый - на место последнего,
   второй - на место предпоследнего, предпослежний - на место второго и тд.
 * @param arr [in] - массив, который необходимо "перевернуть"
 * @param n [in] - количество элементов этого массива
 */
void reverse_arr(int arr[], int n)
{
    int tmp; // временная переменная-буфер
    for (int i = 0; i < n / 2; i++)
    {
        tmp = arr[i];
        arr[i] = arr[n - 1 - i];
        arr[n - 1 - i] = tmp;
    }
}

/**
 * @brief process Функция обрабатывает результат умножения и обрабатывает количество значащих нулей, знак порядка и само число порядка.
 * @param M1 - массив цифр первого числа
 * @param M2 - массив цифр второго числа
 * @param n_1 - количество элементов массива первого числа
 * @param n_2 - количество элементов массива второго числа
 * @param i_point_1 - индекс элемента, перед которым стоит точка в первом числе
 * @param i_point_2 - индекс элемента, перед которым стоит точка во втором числе
 * @param total_point - индекс элемента, перед которым стоит точка в массиве-результате
 * @param P1 - порядок первого числа
 * @param P2 - порядок второго числа
 * @param total_P - порядок результата
 * @param sign_p_1 - знак первого порядка
 * @param sign_p_2 - знак второго порядка
 * @param total_sign_P - знак порядка в результате
 * @param res - массив-результат
 * @param len - количество элементов массива-результата
 * @return Возвращает P_COUNT_ERROR, если превышен допустимый порядок, либо OK в случае успешного завершения работы функции.
 */
int process(int M1[], int M2[], int n_1, int n_2, int i_point_1, int i_point_2, int *total_point, int P1, int P2,
            int *total_P, int sign_p_1, int sign_p_2, int *total_sign_P, int res[], int *len)
{
    assert(n_1 > 0 && n_2 > 0 && *len > 0);
    // переворачиваем оба массива, в которых записаны цифрв мантисс чисел
    reverse_arr(M1, n_1);
    reverse_arr(M2, n_2);
    // если первое число длиннее, чем второе, то оно умножается на второе, иначе - на него умножается второе.
    if (n_1 > n_2)
        mult(M1, M2, n_1, n_2, res, *len);
    else
        mult(M2, M1, n_2, n_1, res, *len);

    // Определение места точки в реверсированном результате
    if (i_point_1 > -1)
    {
        if (i_point_2 > -1)
        {
            *total_point = (n_1 - i_point_1) + (n_2 - i_point_2);
        }
        else
            *total_point = n_1 - i_point_1;
    }
    else if (i_point_1 == -1 && i_point_2 > -1)
        *total_point = n_2 - i_point_2;
    else if (i_point_1 == -1 && i_point_2 == -1)
        *total_point = 0;

    // "удаление" незначащих нулей с конца реверсированного массива-результата
    int i = *len - 1;
    while (res[*len - 1] == 0 && i != *total_point)
    {
        *len -= 1;
        i--;
    }

    // Определение знака порядка и самого числа порядка
    if (sign_p_1 == 1 && sign_p_2 == 1)
    {
        *total_P = P1 + P2;
        *total_sign_P = 1;
    }
    else if (sign_p_1 == -1 && sign_p_2 == -1)
    {
        *total_P = P1 + P2;
        *total_sign_P = -1;
    }
    else if (sign_p_1 == -1 && sign_p_2 == 1)
    {
        if (P1 > P2)
            *total_sign_P = -1;
        else
            *total_sign_P = 1;
        *total_P = abs(P1 - P2);
    }
    else if (sign_p_1 == 1 && sign_p_2 == -1)
    {
        if (P1 > P2)
            *total_sign_P = 1;
        else
            *total_sign_P = -1;
        *total_P = abs(P1 - P2);
    }

    //Перемещение "указателя" на точку и уменьшенее порядка (чтобы нормализовать число)
    for (int j = *total_point; j > -1; j--)
    {
        if (res[j] == 0)
        {
            if (*total_sign_P == 1)
            {
                *total_P -= 1;
                // если само число порядка стало отрицательным, то знак порядка меняется, а число порядка берется по модулю
                if (*total_P < 0)
                {
                    *total_sign_P = -1;
                    *total_P = abs(*total_P);
                }
            }
            else
                *total_P += 1;
            *total_point -= 1;
        }
        else
            break;
    }

    // Удаление незначащих нулей до точки
    while (res[*len - 1] == 0 && i != *total_point)
    {
        *len -= 1;
        i--;
    }

    // Окончательное приведение числа к нормализованному виду
    if (*total_point != *len) // если точка не в конце реверсированного массива-результата
    {
        // Увеличение порядка на количество элементов между "указателем" на  точку и концом реверсированного массива-результата
        if (*total_sign_P > 0)
            *total_P += *len - *total_point;
        else
        {
            *total_P -= *len - *total_point;
            // если само число порядка стало отрицательным, то знак порядка меняется, а число порядка берется по модулю
            if (*total_P < 0)
            {
                *total_sign_P = 1;
                *total_P = abs(*total_P);
            }
        }
        *total_point = *len; // перемещение точки в конец реверсированного массива
    }
    if (*total_P >= 100000)
        return P_COUNT_ERROR; // переполнение порядка - ошибка


    reverse_arr(res, *len); // реверсирование массива-результата - теперь цифры расположены в массиве в прямом порядке
    *total_point = *len - *total_point; // перемещение точки в начало (нормализованное число)

    // подсчет и удаление нулей после значащих цифр после точки (порядок сохраняется)
    int ctmp = 0;
    for (int j = *len - 1; j > -1; j--)
    {
        if (res[j] == 0)
            ctmp++;
        else
            break;
    }
    if (ctmp > 0)
        *len -= ctmp;


    // Если мантисса получившегося после умножения числа больше 30, производится округление с возможным поразрядным переносом
    if (*len > 30)
    {
        // если 31-й разряд больше 5, то к 30-му добавляется единица
        if (res[30] >= 5)
            res[29] += 1;
        // циклический поразрядный перенос в случае переполнения
        for (int j = 29; j > 0; j--)
        {
            if (res[j] > 9 )
            {
                res[j - 1] += 1;
                res[j] = 0;
            }
            else
                break;
        }
        // проверка первого разряда, если он переполнен, то он становится равным 1, а порядок числа увеличивается на один
        if (res[0] > 9)
        {
            res[0] = 1;
            if (*total_sign_P > 0)
                *total_P += 1;
            else
                *total_P -= 1;
            if (*total_P < 0)
            {
                *total_sign_P = 1;
                *total_P = abs(*total_P);
            }
        }
        *len = 30; // окончательная длина мантиссы результата - 30
    }

    return OK; // успешное завершение
}
